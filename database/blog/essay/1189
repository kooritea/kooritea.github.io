{"id":1189,"content":"防抖装饰器\n```javascript\nexport function Debounce(time: number) {\n  let timer: NodeJS.Timer = null\n  let origin: Function = null\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    origin = descriptor.value\n    const func = function (...a: any[]) {\n      if (timer) {\n        clearTimeout(timer)\n        timer = null\n      }\n      timer = setTimeout(origin.bind(this, ...a), time);\n    }\n    descriptor.value = func\n  }\n}\nclass test(){\n  @Debounce(400)\n  highfrequency(){\n     console.log(this)\n     // test{highfrequency: f}  \n  }\n}\n```\n\n这种就很舒服 装饰器之所以能拿到指向实例的this是因为高频方法是由实例调用的\n和@Watch的时候不一样,watch的回调方法是绑定setter的target也就是原型调用的\n\n按照这个思路节流也不难写,不过暂时没用到就先不写了","hide":"","time":"2019-10-17T06:15:40.000Z"}