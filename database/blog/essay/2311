{"id":2311,"content":"看到一个简单版的非对称加密\n\nn00001(n是任意正整数)*任意五位内正整数，结果的后五位一定等于这个任意五位数\n```bash\n23300001*12345=287638512345\n```\n\n把这个n00001拆分成ab两个数\n```bash\nn00001=a*b\n23300001=3699*6299\nab就是一对公私钥\n```\n\n那上面的式子就变成\n```bash\n3699*6299*12345=287638512345\n```\n\n那么\n```bash\n3699(公钥) * 12345(原文)=45664155(原始密文)\n```\n`45664155`是这个乘式的一个中间数，因为我只需要结果的后5位，所以中间数也只需要后5位(想象一下有多个因数的竖式)，那密文就是`64155`\n拿到密文后拥有私钥的人就可以使用`64155(密文)`和`6299(私钥)`相乘得出`404112345`\n这时乘式的所有因数都已经相乘，只不过没有乘后五位外的数，所以`404112345`和原来的乘积`287638512345`的后五位外是不一样的，而后五位，因为n00001这个因数的特性，后五位正是我们和需要的原文一样\n\n一个乘式如果我只需要结果的后n位，那不管怎么分解因数，这些因数不管谁先乘谁，都可以丢弃这些因数相乘产生的中间数的后n位外的数\n\n\n\n在RSA算法中。。。\n算了看不懂","hide":"","time":"2020-07-01T15:34:16.000Z"}