{"id":2311,"content":"看到一个简单版的非对称加密\n\n将一个正整数`n*10^m+1`记为`p`，其中nm都是正整数。\np*任意m位内正整数，结果的后m位一定等于这个任意m位数\n```bash\np*x=y\nx的后五位=y的后五位\n\n当n=233,m=5,x=12345\ny=23300001*12345=287638512345\n```\n\n把这个p拆分成ab两个数\n```bash\np=a*b\n23300001=3699*6299\nab就是一对公私钥\n```\n\n那上面的式子就变成\n```bash\n3699*6299*12345=287638512345\n```\n\n那么\n```bash\n3699(公钥) * 12345(原文)=45664155(原始密文)\n```\n`45664155`是这个乘式的一个中间数，因为我只需要结果的后5位，所以中间数也只需要后5位(想象一下有多个因数的竖式)，那密文就是`64155`\n拿到密文后拥有私钥的人就可以使用`64155(密文)`和`6299(私钥)`相乘得出`404112345`\n这时乘式的所有因数都已经相乘，只不过没有乘后五位外的数，所以`404112345`和原来的乘积`287638512345`的后五位外是不一样的，而后五位，因为p这个因数的特性，后五位正是和我们需要的原文一样\n\n一个乘式如果我只需要结果的后n位，那不管怎么分解因数，这些因数不管谁先乘谁，都可以丢弃这些因数相乘产生的中间数的后n位外的数\n\n\n\n在RSA算法中。。。\n算了看不懂","hide":"","time":"2020-07-01T15:34:16.000Z"}