{"id":2141,"content":"```javascript\nr = function(t, e) {\n  return J(this, void 0, void 0, a.a.mark(function n() {\n      var r;\n      return a.a.wrap(function(n) {\n          for (; ; )\n              switch (n.prev = n.next) {\n              case 0:\n                  return n.prev = 0,\n                  n.next = 3,\n                  _();\n              case 3:\n                  return r = n.sent,\n                  n.abrupt(\"return\", r.spyder(i()(t), e));\n              case 7:\n                  return n.prev = 7,\n                  n.t0 = n.catch(0),\n                  nt(Q.LOAD_WASM_FAIL),\n                  n.abrupt(\"return\", \"error:\" + n.t0.message || \"error:load_wasm_fail\");\n              case 11:\n              case \"end\":\n                  return n.stop()\n              }\n      }, n, this, [[0, 7]])\n  }))\n}\n```\n\nwebpack打包出来的签名方法\nt参数是已经解明的reportData，e参数是从E接口获得的secretRule，E接口不需要签名\n\n这个方法再往前追索已经是连方法名都混淆的完全没办法分析\n有一个研究移动端api的仓库提到新的api用到`spyder_code`来生成签名，完全不知道这怎么用。","hide":"","time":"2020-05-27T12:44:49.000Z"}