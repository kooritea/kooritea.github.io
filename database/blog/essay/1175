{"id":1175,"content":"最后貌似还是只能定义被监听属性的set和get方法\n除了这两个方法还要声明一个变量保存这个属性的值\n这也是angular文档上用的方式\n\n明明如果装饰器能访问实例就没有这么多东西了\n\n现实的写法\n```javascript\nclass Component {\n  private _keyword: string\n  get keyword() {\n    return this._keyword\n  }\n  set keyword(value) {\n    // this指向Component实例\n    const newValue = value\n    const oldValue = _this.keyword\n    // do something\n    this._keyword = value\n  }\n}\n```\n\n理想的写法(唯一也是最大的缺陷就是装饰器内和回调的监听方法完全没办法访问component实例)\n所以这个装饰器也只能打打日志什么的,鸡肋\n```javascript\nclass Component {\n  private keyword: string\n  @Watch('keyword')\n  keywordChange(newVal,oldVal){\n     // this指向了Component实例的原型\n     // do something\n  }\n}\n```\n\n理想装饰器定义如下\n```javascript\nexport function Watch(key: string) {\n  let _value\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    // target指向component实例的原型\n    Object.defineProperty(target, key, {\n      set: function (newValue) {\n        const oldValue = _value\n        _value = newValue\n        target[propertyKey](newValue, oldValue)\n      },\n      get: function () {\n        return _value\n      }\n    })\n  }\n}\n```","hide":"","time":"2019-10-13T18:47:03.000Z"}