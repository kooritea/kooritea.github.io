{"id":2605,"content":"```typescript\n/**\n * 防抖，设定时间内多次调用只执行最后一次  \n * 被该装饰器修饰的方法，返回值将会变成Promise<非Promise类型的原返回值类型>  \n * 当原返回值为Promise时则不变  \n * 返回的Promise将会在方法防抖结束且方法执行完毕后resolve,被防抖过滤掉的调用会reject(DEBOUNCE_CANCEL)  \n * @param time 防抖时间\n * @param getKey 生成key的方法，传入参数为被装饰的方法的入参，只有返回的key相同的调用才会被合并防抖\n */\nexport const Debounce = (time: number, getKey?: (...args: any[]) => string) => {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    const timerStore: {\n      [key: string]: {\n        timer: NodeJS.Timeout,\n        promiseReject: Function\n      }\n    } = {}\n    const origin = descriptor.value\n    descriptor.value = function (...args: any[]) {\n      const timerStoreKey = typeof getKey === 'function' ? getKey(...args) : 'default'\n      if (timerStore[timerStoreKey]) {\n        timerStore[timerStoreKey].promiseReject(DEBOUNCE_CANCEL)\n        clearTimeout(timerStore[timerStoreKey].timer)\n      } else {\n        timerStore[timerStoreKey] = {\n          timer: null,\n          promiseReject: null\n        }\n      }\n      return new Promise((resolve, reject) => {\n        timerStore[timerStoreKey].promiseReject = reject\n        timerStore[timerStoreKey].timer = setTimeout(() => {\n          resolve(origin.call(this, ...args))\n        }, time);\n      })\n    }\n  }\n};\n```\n完美\n之前在前端写过一个，不过那个装饰器没有做防抖结束的返回和根据方法入参决定是否节流。\n这次后端又要用到就重写","hide":"","time":"2020-09-18T19:21:23.000Z"}