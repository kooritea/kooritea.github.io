{"id":2495,"content":"整整搞了一个下午，原来是ID3V2头的size字段算错了，怪不得一旦我修改ID3V2超过一定字节vlc就会读不出来\n\nID3V2用了4个字节表示ID3V2除去10字节的头的大小，但是并不是直接将这四个字节转换成10进制数(惯性思维，就是因为这样算才会出问题)\n而是根据ID3V2私有的规定，每一个字节转换成二进制，用0替换左边第一位，再乘于权重也就是说每一个字节都要和0x7f(01111111)进行与运算。\n(也就是一个28位的二进制数，但是js里面没有二进制数这种操作)\n\n```javascript\nconst sizeView = new Uint8Array(arrayBuffer.slice(6,10))// [0x00,0x06,0x2a,0x67]\nfor(let i=0;i<sizeView.byteLength;i++){\n    sizeView[i] = sizeView[i]&0x7f; // 与0x7f(01111111)与运算\n}\n// 乘于每一位的权重\nsize = sizeView[0]*0x200000+sizeView[1]*0x4000+sizeView[2]*0x80+sizeView[3]\n// 103783\n```\n\n之前这个size没有算对都没有问题是因为我是一个一个标签顺序往下读，读到结束就结束了，不用依靠这个size。\n后来插入专辑图，重写ID3V2头的时候因为这个size算法不对，所以放到vlc就读不出来了\n\n现在既然知道算法那当然也能回写了\n```javascript\n// 先算出不包含头部固定10字节的标签长度(10进制)\nconst size = ID3V2RAW.byteLength - 10 \nconst result = new Uint8Array(4) // [0x00,0x00,0x00,0x00]\nlet a = Math.floor(size/0x200000)\nwriteInt(result,0,1,a)// 这是一个封装的方法，其实就是往result的第0位写入长度为1的正整数a 和result[0] = a等效\n// [0x00,0x00,0x00,0x00]\nlet b = Math.floor((size - a*0x200000)/0x4000)\nwriteInt(result,1,1,b)\n// [0x00,0x06,0x00,0x00]\nlet c = Math.floor((size - a*0x200000 - b*0x4000)/0x80)\nwriteInt(result,2,1,c)\n// [0x00,0x06,0x2a,0x00]\nlet d =  Math.floor((size - a*0x200000 - b*0x4000 - c*0x80))\nwriteInt(result,3,1,d)\n// [0x00,0x06,0x2a,0x67]\n```","hide":"","time":"2020-08-20T12:01:50.000Z"}